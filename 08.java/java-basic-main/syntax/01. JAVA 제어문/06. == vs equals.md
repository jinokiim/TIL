## 원시 데이터 타입과 클래스

자바에서는 기본적으로 다루는 데이터 타입이 존재한다. 

이러한 데이터 타입을 원시 데이터 타입이라고 부르고, 

`boolean, byte, char, short, int, long, float, double` 8개가 있다.

원시 데이터 타입의 변수는 선언되면 메모리(Stack)에 공간이 할당되며,

그 메모리 공간 안에 `실제 값이 들어가게 된다.`

그래서 원시 데이터의 경우 == 연산자는 변수가 가리키는 값을 토대로 비교하게 된다.

 

반면 java.lang.Object 클래스를 비롯해 여기에서 파생된 다른 모든 클래스들은 원시 데이터 타입이 아니다.

클래스는 `new 키워드`를 통한 인스턴스가 만들어지는 시점에

또다른 메모리 구역(Heap)에서 `새로운 공간을 할당`하여 값을 저장하고 변수는 그 값이 저장된 메모리의 주소를 가리키게 된다.

그래서 인스턴스 간 == 연산자를 이용할 경우 그 메모리의 주소를 비교하게 된다.

 

한편 문자열 리터럴과 같은 방식으로 문자열을 생성한 경우는 위와 같은 방식과는 조금 다르다.

`문자열 리터럴`(아래의 s3, s4의 경우)로 문자열을 생성할 때, 이미 같은 문자열을 생성한 적이 있다면(s4의 경우)

새로 메모리 공간을 할당하지 않고,

**새로운 변수는 기존의 문자열이 저장된 메모리(String Pool(Heap))의 주소를 가리키게 된다.**

그래서 이러한 경우에는 == 연산자를 이용하였을 때

같은 주소를 가리키고 있기 때문에 true가 나오게 된다.


```java
int a = 1;
int b = 1;

String s1 = new String("JAVA");
String s2 = new String("JAVA");

String s3 = "JAVA";
String s4 = "JAVA";
```
 이런 상황에서 변수와 메모리의 관계를 그려보면 다음과 같다.

![image](https://user-images.githubusercontent.com/88222461/146157614-639611b3-32d1-4d02-b832-9dcc786979f6.png)


 

즉 == 연산자는 변수가 일차적으로 가리키고 있는 메모리 공간의 값을 기준으로 판단한다.

s1, s2, s3(s4) 변수는 일차적으로 각각 10번지, 11번지, 12번지라는 주소값을 가리키고 있기 때문에

서로 == 연산자를 이용하면 `false`라고 연산하게 된다.

반면 equals 메소드는 구현에 따라 다르지만,

변수가 최종적으로 가리키고 있는 값을 기준으로 판단하여 

다른 번지에 저장되어 있는 s1, s2, s3(s4)에 대해서도 서로 같다고 판단하게 된다.
